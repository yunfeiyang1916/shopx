// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: account/v1/front_user.proto

package accountv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 1 || l > 100 {
		err := LoginRequestValidationError{
			field:  "Username",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 1 || l > 100 {
		err := LoginRequestValidationError{
			field:  "Password",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for VerifyCode

	// no validation rules for VerifyKey

	// no validation rules for Encrypt

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

// Validate checks the field values on LoginLoginReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginLoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginLoginReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginLoginReplyMultiError, or nil if none found.
func (m *LoginLoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginLoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	// no validation rules for UserId

	if len(errors) > 0 {
		return LoginLoginReplyMultiError(errors)
	}

	return nil
}

// LoginLoginReplyMultiError is an error wrapping multiple validation errors
// returned by LoginLoginReply.ValidateAll() if the designated constraints
// aren't met.
type LoginLoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginLoginReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginLoginReplyMultiError) AllErrors() []error { return m }

// LoginLoginReplyValidationError is the validation error returned by
// LoginLoginReply.Validate if the designated constraints aren't met.
type LoginLoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginLoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginLoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginLoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginLoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginLoginReplyValidationError) ErrorName() string { return "LoginLoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginLoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginLoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginLoginReplyValidationError{}

// Validate checks the field values on RegisterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequestMultiError, or nil if none found.
func (m *RegisterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUserAccount()); l < 1 || l > 100 {
		err := RegisterRequestValidationError{
			field:  "UserAccount",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 1 || l > 100 {
		err := RegisterRequestValidationError{
			field:  "Password",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for VerifyCode

	// no validation rules for VerifyKey

	// no validation rules for Encrypt

	// no validation rules for BindType

	// no validation rules for ActivityId

	// no validation rules for SourceUserId

	// no validation rules for SourceUccCode

	if len(errors) > 0 {
		return RegisterRequestMultiError(errors)
	}

	return nil
}

// RegisterRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequestMultiError) AllErrors() []error { return m }

// RegisterRequestValidationError is the validation error returned by
// RegisterRequest.Validate if the designated constraints aren't met.
type RegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequestValidationError) ErrorName() string { return "RegisterRequestValidationError" }

// Error satisfies the builtin error interface
func (e RegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequestValidationError{}

// Validate checks the field values on GetUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserReplyMultiError, or
// nil if none found.
func (m *GetUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for UserAccount

	// no validation rules for UserNickname

	// no validation rules for UserAvatar

	// no validation rules for UserState

	// no validation rules for UserMobile

	// no validation rules for UserIntl

	// no validation rules for UserGender

	if all {
		switch v := interface{}(m.GetUserBirthday()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserReplyValidationError{
					field:  "UserBirthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserReplyValidationError{
					field:  "UserBirthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserBirthday()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserReplyValidationError{
				field:  "UserBirthday",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserEmail

	// no validation rules for UserLevelId

	// no validation rules for UserRealname

	// no validation rules for UserIdcard

	// no validation rules for UserIdcardImages

	// no validation rules for UserIsAuthentication

	// no validation rules for TagIds

	// no validation rules for UserFrom

	// no validation rules for UserNew

	// no validation rules for CurrencyId

	// no validation rules for CurrencySymbolLeft

	// no validation rules for UserMoney

	// no validation rules for UserMoneyFrozen

	// no validation rules for UserRechargeCard

	// no validation rules for UserRechargeCardFrozen

	// no validation rules for UserPoints

	// no validation rules for UserPointsFrozen

	// no validation rules for UserExp

	// no validation rules for UserCredit

	// no validation rules for UserCreditFrozen

	// no validation rules for UserCreditUsed

	// no validation rules for UserCreditTotal

	// no validation rules for UserMargin

	// no validation rules for UserRedpack

	// no validation rules for UserRedpackFrozen

	// no validation rules for RoleId

	// no validation rules for SiteId

	// no validation rules for StoreId

	// no validation rules for ChainId

	// no validation rules for ClientId

	// no validation rules for UdAddress

	// no validation rules for UserLevelName

	if all {
		switch v := interface{}(m.GetUserRegTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserReplyValidationError{
					field:  "UserRegTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserReplyValidationError{
					field:  "UserRegTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserRegTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserReplyValidationError{
				field:  "UserRegTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUserLoginTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserReplyValidationError{
					field:  "UserLoginTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserReplyValidationError{
					field:  "UserLoginTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserLoginTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserReplyValidationError{
				field:  "UserLoginTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TagTitles

	// no validation rules for TagGroupNames

	// no validation rules for TagIdsDuplicate

	// no validation rules for MonthOrder

	// no validation rules for TotalOrder

	// no validation rules for MonthTrade

	// no validation rules for TotalTrade

	// no validation rules for Voucher

	// no validation rules for WaitPayNum

	// no validation rules for FavoritesGoodsNum

	// no validation rules for ConcernNum

	// no validation rules for UnreadNumber

	// no validation rules for CommissionAmount

	// no validation rules for UserCommissionNow

	// no validation rules for MonthCommissionBuy

	// no validation rules for UserParentId

	if len(errors) > 0 {
		return GetUserReplyMultiError(errors)
	}

	return nil
}

// GetUserReplyMultiError is an error wrapping multiple validation errors
// returned by GetUserReply.ValidateAll() if the designated constraints aren't met.
type GetUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserReplyMultiError) AllErrors() []error { return m }

// GetUserReplyValidationError is the validation error returned by
// GetUserReply.Validate if the designated constraints aren't met.
type GetUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserReplyValidationError) ErrorName() string { return "GetUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserReplyValidationError{}

// Validate checks the field values on UpdateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserRequestMultiError, or nil if none found.
func (m *UpdateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for UserNickname

	// no validation rules for UserAvatar

	// no validation rules for UserEmail

	if all {
		switch v := interface{}(m.GetUserBirthday()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserRequestValidationError{
					field:  "UserBirthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserRequestValidationError{
					field:  "UserBirthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserBirthday()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserRequestValidationError{
				field:  "UserBirthday",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserRequestMultiError(errors)
	}

	return nil
}

// UpdateUserRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateUserRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserRequestMultiError) AllErrors() []error { return m }

// UpdateUserRequestValidationError is the validation error returned by
// UpdateUserRequest.Validate if the designated constraints aren't met.
type UpdateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRequestValidationError) ErrorName() string {
	return "UpdateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRequestValidationError{}

// Validate checks the field values on BindMobileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BindMobileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindMobileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BindMobileRequestMultiError, or nil if none found.
func (m *BindMobileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BindMobileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VerifyCode

	// no validation rules for VerifyKey

	if len(errors) > 0 {
		return BindMobileRequestMultiError(errors)
	}

	return nil
}

// BindMobileRequestMultiError is an error wrapping multiple validation errors
// returned by BindMobileRequest.ValidateAll() if the designated constraints
// aren't met.
type BindMobileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindMobileRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindMobileRequestMultiError) AllErrors() []error { return m }

// BindMobileRequestValidationError is the validation error returned by
// BindMobileRequest.Validate if the designated constraints aren't met.
type BindMobileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindMobileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindMobileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindMobileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindMobileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindMobileRequestValidationError) ErrorName() string {
	return "BindMobileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BindMobileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindMobileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindMobileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindMobileRequestValidationError{}

// Validate checks the field values on ResetPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResetPasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResetPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResetPasswordRequestMultiError, or nil if none found.
func (m *ResetPasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResetPasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Password

	// no validation rules for OldPassword

	// no validation rules for VerifyCode

	// no validation rules for VerifyKey

	// no validation rules for Encrypt

	// no validation rules for BindType

	if len(errors) > 0 {
		return ResetPasswordRequestMultiError(errors)
	}

	return nil
}

// ResetPasswordRequestMultiError is an error wrapping multiple validation
// errors returned by ResetPasswordRequest.ValidateAll() if the designated
// constraints aren't met.
type ResetPasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResetPasswordRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResetPasswordRequestMultiError) AllErrors() []error { return m }

// ResetPasswordRequestValidationError is the validation error returned by
// ResetPasswordRequest.Validate if the designated constraints aren't met.
type ResetPasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResetPasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResetPasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResetPasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResetPasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResetPasswordRequestValidationError) ErrorName() string {
	return "ResetPasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResetPasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResetPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResetPasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResetPasswordRequestValidationError{}

// Validate checks the field values on CertificateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CertificateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CertificateRequestMultiError, or nil if none found.
func (m *CertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for UserRealname

	// no validation rules for UserIdcard

	// no validation rules for UserIdcardImages

	if len(errors) > 0 {
		return CertificateRequestMultiError(errors)
	}

	return nil
}

// CertificateRequestMultiError is an error wrapping multiple validation errors
// returned by CertificateRequest.ValidateAll() if the designated constraints
// aren't met.
type CertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CertificateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CertificateRequestMultiError) AllErrors() []error { return m }

// CertificateRequestValidationError is the validation error returned by
// CertificateRequest.Validate if the designated constraints aren't met.
type CertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CertificateRequestValidationError) ErrorName() string {
	return "CertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CertificateRequestValidationError{}

// Validate checks the field values on CreateUserDeliveryAddressReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserDeliveryAddressReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserDeliveryAddressReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserDeliveryAddressReqMultiError, or nil if none found.
func (m *CreateUserDeliveryAddressReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserDeliveryAddressReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UdName

	// no validation rules for UdIntl

	// no validation rules for UdMobile

	// no validation rules for UdTelephone

	// no validation rules for UdProvinceId

	// no validation rules for UdProvince

	// no validation rules for UdCityId

	// no validation rules for UdCity

	// no validation rules for UdCountyId

	// no validation rules for UdCounty

	// no validation rules for UdAddress

	// no validation rules for UdPostalcode

	// no validation rules for UdTagName

	// no validation rules for UdIsDefault

	if len(errors) > 0 {
		return CreateUserDeliveryAddressReqMultiError(errors)
	}

	return nil
}

// CreateUserDeliveryAddressReqMultiError is an error wrapping multiple
// validation errors returned by CreateUserDeliveryAddressReq.ValidateAll() if
// the designated constraints aren't met.
type CreateUserDeliveryAddressReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserDeliveryAddressReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserDeliveryAddressReqMultiError) AllErrors() []error { return m }

// CreateUserDeliveryAddressReqValidationError is the validation error returned
// by CreateUserDeliveryAddressReq.Validate if the designated constraints
// aren't met.
type CreateUserDeliveryAddressReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserDeliveryAddressReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserDeliveryAddressReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserDeliveryAddressReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserDeliveryAddressReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserDeliveryAddressReqValidationError) ErrorName() string {
	return "CreateUserDeliveryAddressReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserDeliveryAddressReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserDeliveryAddressReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserDeliveryAddressReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserDeliveryAddressReqValidationError{}

// Validate checks the field values on CreateUserDeliveryAddressRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserDeliveryAddressRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserDeliveryAddressRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserDeliveryAddressResMultiError, or nil if none found.
func (m *CreateUserDeliveryAddressRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserDeliveryAddressRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UdId

	// no validation rules for UserId

	// no validation rules for UdName

	// no validation rules for UdIntl

	// no validation rules for UdMobile

	// no validation rules for UdTelephone

	// no validation rules for UdProvinceId

	// no validation rules for UdProvince

	// no validation rules for UdCityId

	// no validation rules for UdCity

	// no validation rules for UdCountyId

	// no validation rules for UdCounty

	// no validation rules for UdAddress

	// no validation rules for UdPostalcode

	// no validation rules for UdTagName

	// no validation rules for UdLongitude

	// no validation rules for UdLatitude

	if all {
		switch v := interface{}(m.GetUdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserDeliveryAddressResValidationError{
					field:  "UdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserDeliveryAddressResValidationError{
					field:  "UdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserDeliveryAddressResValidationError{
				field:  "UdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UdIsDefault

	if len(errors) > 0 {
		return CreateUserDeliveryAddressResMultiError(errors)
	}

	return nil
}

// CreateUserDeliveryAddressResMultiError is an error wrapping multiple
// validation errors returned by CreateUserDeliveryAddressRes.ValidateAll() if
// the designated constraints aren't met.
type CreateUserDeliveryAddressResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserDeliveryAddressResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserDeliveryAddressResMultiError) AllErrors() []error { return m }

// CreateUserDeliveryAddressResValidationError is the validation error returned
// by CreateUserDeliveryAddressRes.Validate if the designated constraints
// aren't met.
type CreateUserDeliveryAddressResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserDeliveryAddressResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserDeliveryAddressResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserDeliveryAddressResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserDeliveryAddressResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserDeliveryAddressResValidationError) ErrorName() string {
	return "CreateUserDeliveryAddressResValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserDeliveryAddressResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserDeliveryAddressRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserDeliveryAddressResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserDeliveryAddressResValidationError{}

// Validate checks the field values on UpdateUserDeliveryAddressReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserDeliveryAddressReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserDeliveryAddressReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserDeliveryAddressReqMultiError, or nil if none found.
func (m *UpdateUserDeliveryAddressReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserDeliveryAddressReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UdId

	// no validation rules for UdName

	// no validation rules for UdMobile

	// no validation rules for UdIntl

	// no validation rules for UdAddress

	// no validation rules for UdIsDefault

	if len(errors) > 0 {
		return UpdateUserDeliveryAddressReqMultiError(errors)
	}

	return nil
}

// UpdateUserDeliveryAddressReqMultiError is an error wrapping multiple
// validation errors returned by UpdateUserDeliveryAddressReq.ValidateAll() if
// the designated constraints aren't met.
type UpdateUserDeliveryAddressReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserDeliveryAddressReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserDeliveryAddressReqMultiError) AllErrors() []error { return m }

// UpdateUserDeliveryAddressReqValidationError is the validation error returned
// by UpdateUserDeliveryAddressReq.Validate if the designated constraints
// aren't met.
type UpdateUserDeliveryAddressReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserDeliveryAddressReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserDeliveryAddressReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserDeliveryAddressReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserDeliveryAddressReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserDeliveryAddressReqValidationError) ErrorName() string {
	return "UpdateUserDeliveryAddressReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserDeliveryAddressReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserDeliveryAddressReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserDeliveryAddressReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserDeliveryAddressReqValidationError{}

// Validate checks the field values on UpdateUserDeliveryAddressRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserDeliveryAddressRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserDeliveryAddressRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserDeliveryAddressResMultiError, or nil if none found.
func (m *UpdateUserDeliveryAddressRes) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserDeliveryAddressRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UdId

	if len(errors) > 0 {
		return UpdateUserDeliveryAddressResMultiError(errors)
	}

	return nil
}

// UpdateUserDeliveryAddressResMultiError is an error wrapping multiple
// validation errors returned by UpdateUserDeliveryAddressRes.ValidateAll() if
// the designated constraints aren't met.
type UpdateUserDeliveryAddressResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserDeliveryAddressResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserDeliveryAddressResMultiError) AllErrors() []error { return m }

// UpdateUserDeliveryAddressResValidationError is the validation error returned
// by UpdateUserDeliveryAddressRes.Validate if the designated constraints
// aren't met.
type UpdateUserDeliveryAddressResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserDeliveryAddressResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserDeliveryAddressResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserDeliveryAddressResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserDeliveryAddressResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserDeliveryAddressResValidationError) ErrorName() string {
	return "UpdateUserDeliveryAddressResValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserDeliveryAddressResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserDeliveryAddressRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserDeliveryAddressResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserDeliveryAddressResValidationError{}

// Validate checks the field values on GetUserDeliveryAddressReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserDeliveryAddressReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserDeliveryAddressReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserDeliveryAddressReqMultiError, or nil if none found.
func (m *GetUserDeliveryAddressReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserDeliveryAddressReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UdId

	if len(errors) > 0 {
		return GetUserDeliveryAddressReqMultiError(errors)
	}

	return nil
}

// GetUserDeliveryAddressReqMultiError is an error wrapping multiple validation
// errors returned by GetUserDeliveryAddressReq.ValidateAll() if the
// designated constraints aren't met.
type GetUserDeliveryAddressReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserDeliveryAddressReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserDeliveryAddressReqMultiError) AllErrors() []error { return m }

// GetUserDeliveryAddressReqValidationError is the validation error returned by
// GetUserDeliveryAddressReq.Validate if the designated constraints aren't met.
type GetUserDeliveryAddressReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserDeliveryAddressReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserDeliveryAddressReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserDeliveryAddressReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserDeliveryAddressReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserDeliveryAddressReqValidationError) ErrorName() string {
	return "GetUserDeliveryAddressReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserDeliveryAddressReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserDeliveryAddressReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserDeliveryAddressReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserDeliveryAddressReqValidationError{}

// Validate checks the field values on DeleteUserDeliveryAddressReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteUserDeliveryAddressReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserDeliveryAddressReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteUserDeliveryAddressReqMultiError, or nil if none found.
func (m *DeleteUserDeliveryAddressReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserDeliveryAddressReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UdId

	if len(errors) > 0 {
		return DeleteUserDeliveryAddressReqMultiError(errors)
	}

	return nil
}

// DeleteUserDeliveryAddressReqMultiError is an error wrapping multiple
// validation errors returned by DeleteUserDeliveryAddressReq.ValidateAll() if
// the designated constraints aren't met.
type DeleteUserDeliveryAddressReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserDeliveryAddressReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserDeliveryAddressReqMultiError) AllErrors() []error { return m }

// DeleteUserDeliveryAddressReqValidationError is the validation error returned
// by DeleteUserDeliveryAddressReq.Validate if the designated constraints
// aren't met.
type DeleteUserDeliveryAddressReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserDeliveryAddressReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserDeliveryAddressReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserDeliveryAddressReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserDeliveryAddressReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserDeliveryAddressReqValidationError) ErrorName() string {
	return "DeleteUserDeliveryAddressReqValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteUserDeliveryAddressReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserDeliveryAddressReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserDeliveryAddressReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserDeliveryAddressReqValidationError{}

// Validate checks the field values on ListUserDeliveryAddressReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserDeliveryAddressReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserDeliveryAddressReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserDeliveryAddressReqMultiError, or nil if none found.
func (m *ListUserDeliveryAddressReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserDeliveryAddressReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBaseList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListUserDeliveryAddressReqValidationError{
					field:  "BaseList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListUserDeliveryAddressReqValidationError{
					field:  "BaseList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUserDeliveryAddressReqValidationError{
				field:  "BaseList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UdName

	if len(errors) > 0 {
		return ListUserDeliveryAddressReqMultiError(errors)
	}

	return nil
}

// ListUserDeliveryAddressReqMultiError is an error wrapping multiple
// validation errors returned by ListUserDeliveryAddressReq.ValidateAll() if
// the designated constraints aren't met.
type ListUserDeliveryAddressReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserDeliveryAddressReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserDeliveryAddressReqMultiError) AllErrors() []error { return m }

// ListUserDeliveryAddressReqValidationError is the validation error returned
// by ListUserDeliveryAddressReq.Validate if the designated constraints aren't met.
type ListUserDeliveryAddressReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserDeliveryAddressReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserDeliveryAddressReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserDeliveryAddressReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserDeliveryAddressReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserDeliveryAddressReqValidationError) ErrorName() string {
	return "ListUserDeliveryAddressReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserDeliveryAddressReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserDeliveryAddressReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserDeliveryAddressReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserDeliveryAddressReqValidationError{}

// Validate checks the field values on UserDeliveryAddressListRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserDeliveryAddressListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserDeliveryAddressListRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserDeliveryAddressListResMultiError, or nil if none found.
func (m *UserDeliveryAddressListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *UserDeliveryAddressListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserDeliveryAddressListResValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserDeliveryAddressListResValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserDeliveryAddressListResValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Page

	// no validation rules for Total

	// no validation rules for Records

	// no validation rules for Size

	if len(errors) > 0 {
		return UserDeliveryAddressListResMultiError(errors)
	}

	return nil
}

// UserDeliveryAddressListResMultiError is an error wrapping multiple
// validation errors returned by UserDeliveryAddressListRes.ValidateAll() if
// the designated constraints aren't met.
type UserDeliveryAddressListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserDeliveryAddressListResMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserDeliveryAddressListResMultiError) AllErrors() []error { return m }

// UserDeliveryAddressListResValidationError is the validation error returned
// by UserDeliveryAddressListRes.Validate if the designated constraints aren't met.
type UserDeliveryAddressListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserDeliveryAddressListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserDeliveryAddressListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserDeliveryAddressListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserDeliveryAddressListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserDeliveryAddressListResValidationError) ErrorName() string {
	return "UserDeliveryAddressListResValidationError"
}

// Error satisfies the builtin error interface
func (e UserDeliveryAddressListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserDeliveryAddressListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserDeliveryAddressListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserDeliveryAddressListResValidationError{}
