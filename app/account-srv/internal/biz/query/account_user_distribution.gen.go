// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"shopx/app/account-srv/internal/biz/entity"
)

func newAccountUserDistribution(db *gorm.DB, opts ...gen.DOOption) accountUserDistribution {
	_accountUserDistribution := accountUserDistribution{}

	_accountUserDistribution.accountUserDistributionDo.UseDB(db, opts...)
	_accountUserDistribution.accountUserDistributionDo.UseModel(&entity.AccountUserDistribution{})

	tableName := _accountUserDistribution.accountUserDistributionDo.TableName()
	_accountUserDistribution.ALL = field.NewAsterisk(tableName)
	_accountUserDistribution.UserID = field.NewInt32(tableName, "user_id")
	_accountUserDistribution.UserParentID = field.NewInt32(tableName, "user_parent_id")
	_accountUserDistribution.UserPartnerID = field.NewInt32(tableName, "user_partner_id")
	_accountUserDistribution.UserTeamCount = field.NewInt32(tableName, "user_team_count")
	_accountUserDistribution.UserProvinceTeamID = field.NewInt32(tableName, "user_province_team_id")
	_accountUserDistribution.UserCityTeamID = field.NewInt32(tableName, "user_city_team_id")
	_accountUserDistribution.UserCountyTeamID = field.NewInt32(tableName, "user_county_team_id")
	_accountUserDistribution.RoleLevelID = field.NewInt32(tableName, "role_level_id")
	_accountUserDistribution.UccID = field.NewInt32(tableName, "ucc_id")
	_accountUserDistribution.ActivityID = field.NewInt32(tableName, "activity_id")
	_accountUserDistribution.UserTime = field.NewInt64(tableName, "user_time")
	_accountUserDistribution.UserFansNum = field.NewInt32(tableName, "user_fans_num")
	_accountUserDistribution.UserIsSp = field.NewField(tableName, "user_is_sp")
	_accountUserDistribution.UserIsDa = field.NewInt32(tableName, "user_is_da")
	_accountUserDistribution.UserIsCa = field.NewInt32(tableName, "user_is_ca")
	_accountUserDistribution.UserIsPa = field.NewInt32(tableName, "user_is_pa")
	_accountUserDistribution.UserIsPt = field.NewField(tableName, "user_is_pt")
	_accountUserDistribution.UserActive = field.NewField(tableName, "user_active")
	_accountUserDistribution.UserVoucherIds = field.NewString(tableName, "user_voucher_ids")

	_accountUserDistribution.fillFieldMap()

	return _accountUserDistribution
}

// accountUserDistribution 粉丝来源关系表
type accountUserDistribution struct {
	accountUserDistributionDo accountUserDistributionDo

	ALL                field.Asterisk
	UserID             field.Int32  // 用户编号
	UserParentID       field.Int32  // 上级用户编号
	UserPartnerID      field.Int32  // 所属城市合伙人
	UserTeamCount      field.Int32  // 团队人数
	UserProvinceTeamID field.Int32  // 所属省公司
	UserCityTeamID     field.Int32  // 所属市公司
	UserCountyTeamID   field.Int32  // 所属区公司
	RoleLevelID        field.Int32  // 角色等级
	UccID              field.Int32  // 渠道编号
	ActivityID         field.Int32  // 活动编号
	UserTime           field.Int64  // 注册时间
	UserFansNum        field.Int32  // 粉丝数量:冗余
	UserIsSp           field.Field  // 服务商(BOOL):0-否;1-是;
	UserIsDa           field.Int32  // 区代理(BOOL):0-否;1-是为区Id;
	UserIsCa           field.Int32  // 市代理(BOOL):0-否;1-是为市Id;
	UserIsPa           field.Int32  // 省代理(BOOL):0-否;1-是为省Id;
	UserIsPt           field.Field  // 城市合伙人(BOOL):0-否;1-是;
	UserActive         field.Field  // 是否有效(BOOL):0-未生效;1-有效
	UserVoucherIds     field.String // 分销优惠券

	fieldMap map[string]field.Expr
}

func (a accountUserDistribution) Table(newTableName string) *accountUserDistribution {
	a.accountUserDistributionDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a accountUserDistribution) As(alias string) *accountUserDistribution {
	a.accountUserDistributionDo.DO = *(a.accountUserDistributionDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *accountUserDistribution) updateTableName(table string) *accountUserDistribution {
	a.ALL = field.NewAsterisk(table)
	a.UserID = field.NewInt32(table, "user_id")
	a.UserParentID = field.NewInt32(table, "user_parent_id")
	a.UserPartnerID = field.NewInt32(table, "user_partner_id")
	a.UserTeamCount = field.NewInt32(table, "user_team_count")
	a.UserProvinceTeamID = field.NewInt32(table, "user_province_team_id")
	a.UserCityTeamID = field.NewInt32(table, "user_city_team_id")
	a.UserCountyTeamID = field.NewInt32(table, "user_county_team_id")
	a.RoleLevelID = field.NewInt32(table, "role_level_id")
	a.UccID = field.NewInt32(table, "ucc_id")
	a.ActivityID = field.NewInt32(table, "activity_id")
	a.UserTime = field.NewInt64(table, "user_time")
	a.UserFansNum = field.NewInt32(table, "user_fans_num")
	a.UserIsSp = field.NewField(table, "user_is_sp")
	a.UserIsDa = field.NewInt32(table, "user_is_da")
	a.UserIsCa = field.NewInt32(table, "user_is_ca")
	a.UserIsPa = field.NewInt32(table, "user_is_pa")
	a.UserIsPt = field.NewField(table, "user_is_pt")
	a.UserActive = field.NewField(table, "user_active")
	a.UserVoucherIds = field.NewString(table, "user_voucher_ids")

	a.fillFieldMap()

	return a
}

func (a *accountUserDistribution) WithContext(ctx context.Context) *accountUserDistributionDo {
	return a.accountUserDistributionDo.WithContext(ctx)
}

func (a accountUserDistribution) TableName() string { return a.accountUserDistributionDo.TableName() }

func (a accountUserDistribution) Alias() string { return a.accountUserDistributionDo.Alias() }

func (a accountUserDistribution) Columns(cols ...field.Expr) gen.Columns {
	return a.accountUserDistributionDo.Columns(cols...)
}

func (a *accountUserDistribution) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *accountUserDistribution) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 19)
	a.fieldMap["user_id"] = a.UserID
	a.fieldMap["user_parent_id"] = a.UserParentID
	a.fieldMap["user_partner_id"] = a.UserPartnerID
	a.fieldMap["user_team_count"] = a.UserTeamCount
	a.fieldMap["user_province_team_id"] = a.UserProvinceTeamID
	a.fieldMap["user_city_team_id"] = a.UserCityTeamID
	a.fieldMap["user_county_team_id"] = a.UserCountyTeamID
	a.fieldMap["role_level_id"] = a.RoleLevelID
	a.fieldMap["ucc_id"] = a.UccID
	a.fieldMap["activity_id"] = a.ActivityID
	a.fieldMap["user_time"] = a.UserTime
	a.fieldMap["user_fans_num"] = a.UserFansNum
	a.fieldMap["user_is_sp"] = a.UserIsSp
	a.fieldMap["user_is_da"] = a.UserIsDa
	a.fieldMap["user_is_ca"] = a.UserIsCa
	a.fieldMap["user_is_pa"] = a.UserIsPa
	a.fieldMap["user_is_pt"] = a.UserIsPt
	a.fieldMap["user_active"] = a.UserActive
	a.fieldMap["user_voucher_ids"] = a.UserVoucherIds
}

func (a accountUserDistribution) clone(db *gorm.DB) accountUserDistribution {
	a.accountUserDistributionDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a accountUserDistribution) replaceDB(db *gorm.DB) accountUserDistribution {
	a.accountUserDistributionDo.ReplaceDB(db)
	return a
}

type accountUserDistributionDo struct{ gen.DO }

func (a accountUserDistributionDo) Debug() *accountUserDistributionDo {
	return a.withDO(a.DO.Debug())
}

func (a accountUserDistributionDo) WithContext(ctx context.Context) *accountUserDistributionDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a accountUserDistributionDo) ReadDB() *accountUserDistributionDo {
	return a.Clauses(dbresolver.Read)
}

func (a accountUserDistributionDo) WriteDB() *accountUserDistributionDo {
	return a.Clauses(dbresolver.Write)
}

func (a accountUserDistributionDo) Session(config *gorm.Session) *accountUserDistributionDo {
	return a.withDO(a.DO.Session(config))
}

func (a accountUserDistributionDo) Clauses(conds ...clause.Expression) *accountUserDistributionDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a accountUserDistributionDo) Returning(value interface{}, columns ...string) *accountUserDistributionDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a accountUserDistributionDo) Not(conds ...gen.Condition) *accountUserDistributionDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a accountUserDistributionDo) Or(conds ...gen.Condition) *accountUserDistributionDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a accountUserDistributionDo) Select(conds ...field.Expr) *accountUserDistributionDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a accountUserDistributionDo) Where(conds ...gen.Condition) *accountUserDistributionDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a accountUserDistributionDo) Order(conds ...field.Expr) *accountUserDistributionDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a accountUserDistributionDo) Distinct(cols ...field.Expr) *accountUserDistributionDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a accountUserDistributionDo) Omit(cols ...field.Expr) *accountUserDistributionDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a accountUserDistributionDo) Join(table schema.Tabler, on ...field.Expr) *accountUserDistributionDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a accountUserDistributionDo) LeftJoin(table schema.Tabler, on ...field.Expr) *accountUserDistributionDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a accountUserDistributionDo) RightJoin(table schema.Tabler, on ...field.Expr) *accountUserDistributionDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a accountUserDistributionDo) Group(cols ...field.Expr) *accountUserDistributionDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a accountUserDistributionDo) Having(conds ...gen.Condition) *accountUserDistributionDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a accountUserDistributionDo) Limit(limit int) *accountUserDistributionDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a accountUserDistributionDo) Offset(offset int) *accountUserDistributionDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a accountUserDistributionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *accountUserDistributionDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a accountUserDistributionDo) Unscoped() *accountUserDistributionDo {
	return a.withDO(a.DO.Unscoped())
}

func (a accountUserDistributionDo) Create(values ...*entity.AccountUserDistribution) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a accountUserDistributionDo) CreateInBatches(values []*entity.AccountUserDistribution, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a accountUserDistributionDo) Save(values ...*entity.AccountUserDistribution) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a accountUserDistributionDo) First() (*entity.AccountUserDistribution, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserDistribution), nil
	}
}

func (a accountUserDistributionDo) Take() (*entity.AccountUserDistribution, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserDistribution), nil
	}
}

func (a accountUserDistributionDo) Last() (*entity.AccountUserDistribution, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserDistribution), nil
	}
}

func (a accountUserDistributionDo) Find() ([]*entity.AccountUserDistribution, error) {
	result, err := a.DO.Find()
	return result.([]*entity.AccountUserDistribution), err
}

func (a accountUserDistributionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.AccountUserDistribution, err error) {
	buf := make([]*entity.AccountUserDistribution, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a accountUserDistributionDo) FindInBatches(result *[]*entity.AccountUserDistribution, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a accountUserDistributionDo) Attrs(attrs ...field.AssignExpr) *accountUserDistributionDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a accountUserDistributionDo) Assign(attrs ...field.AssignExpr) *accountUserDistributionDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a accountUserDistributionDo) Joins(fields ...field.RelationField) *accountUserDistributionDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a accountUserDistributionDo) Preload(fields ...field.RelationField) *accountUserDistributionDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a accountUserDistributionDo) FirstOrInit() (*entity.AccountUserDistribution, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserDistribution), nil
	}
}

func (a accountUserDistributionDo) FirstOrCreate() (*entity.AccountUserDistribution, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserDistribution), nil
	}
}

func (a accountUserDistributionDo) FindByPage(offset int, limit int) (result []*entity.AccountUserDistribution, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a accountUserDistributionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a accountUserDistributionDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a accountUserDistributionDo) Delete(models ...*entity.AccountUserDistribution) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *accountUserDistributionDo) withDO(do gen.Dao) *accountUserDistributionDo {
	a.DO = *do.(*gen.DO)
	return a
}
