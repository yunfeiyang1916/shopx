// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"shopx/app/account-srv/internal/biz/entity"
)

func newAccountUserInvoice(db *gorm.DB, opts ...gen.DOOption) accountUserInvoice {
	_accountUserInvoice := accountUserInvoice{}

	_accountUserInvoice.accountUserInvoiceDo.UseDB(db, opts...)
	_accountUserInvoice.accountUserInvoiceDo.UseModel(&entity.AccountUserInvoice{})

	tableName := _accountUserInvoice.accountUserInvoiceDo.TableName()
	_accountUserInvoice.ALL = field.NewAsterisk(tableName)
	_accountUserInvoice.UserInvoiceID = field.NewInt32(tableName, "user_invoice_id")
	_accountUserInvoice.UserID = field.NewInt32(tableName, "user_id")
	_accountUserInvoice.InvoiceTitle = field.NewString(tableName, "invoice_title")
	_accountUserInvoice.InvoiceCompanyCode = field.NewString(tableName, "invoice_company_code")
	_accountUserInvoice.InvoiceContent = field.NewString(tableName, "invoice_content")
	_accountUserInvoice.InvoiceIsCompany = field.NewField(tableName, "invoice_is_company")
	_accountUserInvoice.InvoiceIsElectronic = field.NewField(tableName, "invoice_is_electronic")
	_accountUserInvoice.InvoiceType = field.NewInt32(tableName, "invoice_type")
	_accountUserInvoice.InvoiceDatetime = field.NewTime(tableName, "invoice_datetime")
	_accountUserInvoice.InvoiceAddress = field.NewString(tableName, "invoice_address")
	_accountUserInvoice.InvoicePhone = field.NewString(tableName, "invoice_phone")
	_accountUserInvoice.InvoiceBankname = field.NewString(tableName, "invoice_bankname")
	_accountUserInvoice.InvoiceBankaccount = field.NewString(tableName, "invoice_bankaccount")
	_accountUserInvoice.InvoiceContactMobile = field.NewString(tableName, "invoice_contact_mobile")
	_accountUserInvoice.InvoiceContactEmail = field.NewString(tableName, "invoice_contact_email")
	_accountUserInvoice.InvoiceIsDefault = field.NewBool(tableName, "invoice_is_default")
	_accountUserInvoice.InvoiceContactName = field.NewString(tableName, "invoice_contact_name")
	_accountUserInvoice.InvoiceContactArea = field.NewString(tableName, "invoice_contact_area")
	_accountUserInvoice.InvoiceContactAddress = field.NewString(tableName, "invoice_contact_address")

	_accountUserInvoice.fillFieldMap()

	return _accountUserInvoice
}

// accountUserInvoice 用户发票管理表
type accountUserInvoice struct {
	accountUserInvoiceDo accountUserInvoiceDo

	ALL                   field.Asterisk
	UserInvoiceID         field.Int32  // 发票编号
	UserID                field.Int32  // 所属用户
	InvoiceTitle          field.String // 发票抬头
	InvoiceCompanyCode    field.String // 纳税人识别号
	InvoiceContent        field.String // 发票内容
	InvoiceIsCompany      field.Field  // 公司开票(BOOL):0-个人;1-公司
	InvoiceIsElectronic   field.Field  // 电子发票(ENUM):0-纸质发票;1-电子发票
	InvoiceType           field.Int32  // 发票类型(ENUM):1-普通发票;2-增值税专用发票
	InvoiceDatetime       field.Time   // 添加时间
	InvoiceAddress        field.String // 单位地址
	InvoicePhone          field.String // 单位电话
	InvoiceBankname       field.String // 开户银行
	InvoiceBankaccount    field.String // 银行账号
	InvoiceContactMobile  field.String // 收票人手机
	InvoiceContactEmail   field.String // 收票人邮箱
	InvoiceIsDefault      field.Bool   // 是否默认
	InvoiceContactName    field.String // 收票人
	InvoiceContactArea    field.String // 收票人地区
	InvoiceContactAddress field.String // 收票详细地址

	fieldMap map[string]field.Expr
}

func (a accountUserInvoice) Table(newTableName string) *accountUserInvoice {
	a.accountUserInvoiceDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a accountUserInvoice) As(alias string) *accountUserInvoice {
	a.accountUserInvoiceDo.DO = *(a.accountUserInvoiceDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *accountUserInvoice) updateTableName(table string) *accountUserInvoice {
	a.ALL = field.NewAsterisk(table)
	a.UserInvoiceID = field.NewInt32(table, "user_invoice_id")
	a.UserID = field.NewInt32(table, "user_id")
	a.InvoiceTitle = field.NewString(table, "invoice_title")
	a.InvoiceCompanyCode = field.NewString(table, "invoice_company_code")
	a.InvoiceContent = field.NewString(table, "invoice_content")
	a.InvoiceIsCompany = field.NewField(table, "invoice_is_company")
	a.InvoiceIsElectronic = field.NewField(table, "invoice_is_electronic")
	a.InvoiceType = field.NewInt32(table, "invoice_type")
	a.InvoiceDatetime = field.NewTime(table, "invoice_datetime")
	a.InvoiceAddress = field.NewString(table, "invoice_address")
	a.InvoicePhone = field.NewString(table, "invoice_phone")
	a.InvoiceBankname = field.NewString(table, "invoice_bankname")
	a.InvoiceBankaccount = field.NewString(table, "invoice_bankaccount")
	a.InvoiceContactMobile = field.NewString(table, "invoice_contact_mobile")
	a.InvoiceContactEmail = field.NewString(table, "invoice_contact_email")
	a.InvoiceIsDefault = field.NewBool(table, "invoice_is_default")
	a.InvoiceContactName = field.NewString(table, "invoice_contact_name")
	a.InvoiceContactArea = field.NewString(table, "invoice_contact_area")
	a.InvoiceContactAddress = field.NewString(table, "invoice_contact_address")

	a.fillFieldMap()

	return a
}

func (a *accountUserInvoice) WithContext(ctx context.Context) *accountUserInvoiceDo {
	return a.accountUserInvoiceDo.WithContext(ctx)
}

func (a accountUserInvoice) TableName() string { return a.accountUserInvoiceDo.TableName() }

func (a accountUserInvoice) Alias() string { return a.accountUserInvoiceDo.Alias() }

func (a accountUserInvoice) Columns(cols ...field.Expr) gen.Columns {
	return a.accountUserInvoiceDo.Columns(cols...)
}

func (a *accountUserInvoice) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *accountUserInvoice) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 19)
	a.fieldMap["user_invoice_id"] = a.UserInvoiceID
	a.fieldMap["user_id"] = a.UserID
	a.fieldMap["invoice_title"] = a.InvoiceTitle
	a.fieldMap["invoice_company_code"] = a.InvoiceCompanyCode
	a.fieldMap["invoice_content"] = a.InvoiceContent
	a.fieldMap["invoice_is_company"] = a.InvoiceIsCompany
	a.fieldMap["invoice_is_electronic"] = a.InvoiceIsElectronic
	a.fieldMap["invoice_type"] = a.InvoiceType
	a.fieldMap["invoice_datetime"] = a.InvoiceDatetime
	a.fieldMap["invoice_address"] = a.InvoiceAddress
	a.fieldMap["invoice_phone"] = a.InvoicePhone
	a.fieldMap["invoice_bankname"] = a.InvoiceBankname
	a.fieldMap["invoice_bankaccount"] = a.InvoiceBankaccount
	a.fieldMap["invoice_contact_mobile"] = a.InvoiceContactMobile
	a.fieldMap["invoice_contact_email"] = a.InvoiceContactEmail
	a.fieldMap["invoice_is_default"] = a.InvoiceIsDefault
	a.fieldMap["invoice_contact_name"] = a.InvoiceContactName
	a.fieldMap["invoice_contact_area"] = a.InvoiceContactArea
	a.fieldMap["invoice_contact_address"] = a.InvoiceContactAddress
}

func (a accountUserInvoice) clone(db *gorm.DB) accountUserInvoice {
	a.accountUserInvoiceDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a accountUserInvoice) replaceDB(db *gorm.DB) accountUserInvoice {
	a.accountUserInvoiceDo.ReplaceDB(db)
	return a
}

type accountUserInvoiceDo struct{ gen.DO }

func (a accountUserInvoiceDo) Debug() *accountUserInvoiceDo {
	return a.withDO(a.DO.Debug())
}

func (a accountUserInvoiceDo) WithContext(ctx context.Context) *accountUserInvoiceDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a accountUserInvoiceDo) ReadDB() *accountUserInvoiceDo {
	return a.Clauses(dbresolver.Read)
}

func (a accountUserInvoiceDo) WriteDB() *accountUserInvoiceDo {
	return a.Clauses(dbresolver.Write)
}

func (a accountUserInvoiceDo) Session(config *gorm.Session) *accountUserInvoiceDo {
	return a.withDO(a.DO.Session(config))
}

func (a accountUserInvoiceDo) Clauses(conds ...clause.Expression) *accountUserInvoiceDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a accountUserInvoiceDo) Returning(value interface{}, columns ...string) *accountUserInvoiceDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a accountUserInvoiceDo) Not(conds ...gen.Condition) *accountUserInvoiceDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a accountUserInvoiceDo) Or(conds ...gen.Condition) *accountUserInvoiceDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a accountUserInvoiceDo) Select(conds ...field.Expr) *accountUserInvoiceDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a accountUserInvoiceDo) Where(conds ...gen.Condition) *accountUserInvoiceDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a accountUserInvoiceDo) Order(conds ...field.Expr) *accountUserInvoiceDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a accountUserInvoiceDo) Distinct(cols ...field.Expr) *accountUserInvoiceDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a accountUserInvoiceDo) Omit(cols ...field.Expr) *accountUserInvoiceDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a accountUserInvoiceDo) Join(table schema.Tabler, on ...field.Expr) *accountUserInvoiceDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a accountUserInvoiceDo) LeftJoin(table schema.Tabler, on ...field.Expr) *accountUserInvoiceDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a accountUserInvoiceDo) RightJoin(table schema.Tabler, on ...field.Expr) *accountUserInvoiceDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a accountUserInvoiceDo) Group(cols ...field.Expr) *accountUserInvoiceDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a accountUserInvoiceDo) Having(conds ...gen.Condition) *accountUserInvoiceDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a accountUserInvoiceDo) Limit(limit int) *accountUserInvoiceDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a accountUserInvoiceDo) Offset(offset int) *accountUserInvoiceDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a accountUserInvoiceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *accountUserInvoiceDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a accountUserInvoiceDo) Unscoped() *accountUserInvoiceDo {
	return a.withDO(a.DO.Unscoped())
}

func (a accountUserInvoiceDo) Create(values ...*entity.AccountUserInvoice) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a accountUserInvoiceDo) CreateInBatches(values []*entity.AccountUserInvoice, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a accountUserInvoiceDo) Save(values ...*entity.AccountUserInvoice) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a accountUserInvoiceDo) First() (*entity.AccountUserInvoice, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserInvoice), nil
	}
}

func (a accountUserInvoiceDo) Take() (*entity.AccountUserInvoice, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserInvoice), nil
	}
}

func (a accountUserInvoiceDo) Last() (*entity.AccountUserInvoice, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserInvoice), nil
	}
}

func (a accountUserInvoiceDo) Find() ([]*entity.AccountUserInvoice, error) {
	result, err := a.DO.Find()
	return result.([]*entity.AccountUserInvoice), err
}

func (a accountUserInvoiceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.AccountUserInvoice, err error) {
	buf := make([]*entity.AccountUserInvoice, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a accountUserInvoiceDo) FindInBatches(result *[]*entity.AccountUserInvoice, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a accountUserInvoiceDo) Attrs(attrs ...field.AssignExpr) *accountUserInvoiceDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a accountUserInvoiceDo) Assign(attrs ...field.AssignExpr) *accountUserInvoiceDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a accountUserInvoiceDo) Joins(fields ...field.RelationField) *accountUserInvoiceDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a accountUserInvoiceDo) Preload(fields ...field.RelationField) *accountUserInvoiceDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a accountUserInvoiceDo) FirstOrInit() (*entity.AccountUserInvoice, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserInvoice), nil
	}
}

func (a accountUserInvoiceDo) FirstOrCreate() (*entity.AccountUserInvoice, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*entity.AccountUserInvoice), nil
	}
}

func (a accountUserInvoiceDo) FindByPage(offset int, limit int) (result []*entity.AccountUserInvoice, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a accountUserInvoiceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a accountUserInvoiceDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a accountUserInvoiceDo) Delete(models ...*entity.AccountUserInvoice) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *accountUserInvoiceDo) withDO(do gen.Dao) *accountUserInvoiceDo {
	a.DO = *do.(*gen.DO)
	return a
}
